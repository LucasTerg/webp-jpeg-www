{"version":3,"file":"client-processor-C-jpqM5i.js","sources":["../../src/js/client-processor.js"],"sourcesContent":["import JSZip from 'jszip';\n\nconsole.log(\"Client processor module loaded\");\n\n// Funkcja pomocnicza do ładowania obrazu\nconst loadImage = (file) => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n// Algorytm TRIM (Scanlines)\nconst getTrimmedBounds = (ctx, width, height) => {\n  const pixels = ctx.getImageData(0, 0, width, height).data;\n  let top = 0, bottom = height, left = 0, right = width;\n\n  // Funkcja sprawdzająca czy piksel jest \"tłem\" (biały lub przezroczysty)\n  // Tolerancja dla bieli: RGB > 230\n  const isBackground = (r, g, b, a) => {\n    const isWhite = r > 230 && g > 230 && b > 230;\n    const isTransparent = a < 255;\n    return isWhite || isTransparent;\n  };\n\n  // Skanowanie z góry\n  for (top = 0; top < height; top++) {\n    let rowHasContent = false;\n    for (let x = 0; x < width; x++) {\n      const i = (top * width + x) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        rowHasContent = true;\n        break;\n      }\n    }\n    if (rowHasContent) break;\n  }\n\n  // Jeśli obraz jest pusty (samo tło)\n  if (top === height) return null;\n\n  // Skanowanie z dołu\n  for (bottom = height - 1; bottom >= top; bottom--) {\n    let rowHasContent = false;\n    for (let x = 0; x < width; x++) {\n      const i = (bottom * width + x) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        rowHasContent = true;\n        break;\n      }\n    }\n    if (rowHasContent) break;\n  }\n  // Skanowanie z lewej\n  for (left = 0; left < width; left++) {\n    let colHasContent = false;\n    for (let y = top; y <= bottom; y++) {\n      const i = (y * width + left) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        colHasContent = true;\n        break;\n      }\n    }\n    if (colHasContent) break;\n  }\n\n  // Skanowanie z prawej\n  for (right = width - 1; right >= left; right--) {\n    let colHasContent = false;\n    for (let y = top; y <= bottom; y++) {\n      const i = (y * width + right) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        colHasContent = true;\n        break;\n      }\n    }\n    if (colHasContent) break;\n  }\n  \n  return { x: left, y: top, width: right - left + 1, height: bottom - top + 1 };\n};\n\nexport const processFilesClientSide = async (filesQueue, options, onProgress) => {\n  const zip = new JSZip();\n  const { baseName, startNumber, optCrop, optTrimOnly, optAddMargin, optResize } = options;\n\n  let processedCount = 0;\n\n  for (let i = 0; i < filesQueue.length; i++) {\n    const fileItem = filesQueue[i];\n    const file = fileItem.file;\n    \n    // Raportowanie postępu\n    if (onProgress) onProgress(`Przetwarzanie: ${file.name} (${i + 1}/${filesQueue.length})`);\n\n    try {\n      const img = await loadImage(file);\n      let canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      let ctx = canvas.getContext('2d', { willReadFrequently: true });\n      \n      // Rysujemy oryginał\n      ctx.drawImage(img, 0, 0);\n\n      // Logika flagi \"Should Add Margin\" (z serwera: białe rogi lub przezroczystość)\n      // Sprawdzamy 4 rogi oryginału\n      let shouldAddMargin = false;\n      \n      // Sprawdzamy warunki do kadrowania jeśli którakolwiek opcja jest włączona\n      if (optCrop || optTrimOnly) {\n          const corners = [\n            { x: 0, y: 0 },\n            { x: img.width - 1, y: 0 },\n            { x: 0, y: img.height - 1 },\n            { x: img.width - 1, y: img.height - 1 }\n          ];\n          const pixels = ctx.getImageData(0, 0, img.width, img.height).data;\n          \n          for(let corner of corners) {\n             const idx = (corner.y * img.width + corner.x) * 4;\n             const r = pixels[idx];\n             const g = pixels[idx+1];\n             const b = pixels[idx+2];\n             const a = pixels[idx+3];\n             \n             // Biały lub Przezroczysty\n             if ((r > 230 && g > 230 && b > 230) || a < 255) {\n                 shouldAddMargin = true;\n                 break;\n             }\n          }\n\n          // Logika TRIM\n          const bounds = getTrimmedBounds(ctx, canvas.width, canvas.height);\n          \n          if (bounds) {\n              // Sprawdź czy wymiary się zmieniły (czy coś przycięto)\n              // Uwaga: bounds może być null jeśli obraz pusty.\n              // Sprawdzamy różnicę wymiarów\n              if (bounds.width < canvas.width || bounds.height < canvas.height) {\n                  shouldAddMargin = true;\n              }\n\n              // Tworzymy nowy canvas dla przyciętego obrazu\n              const trimmedCanvas = document.createElement('canvas');\n              trimmedCanvas.width = bounds.width;\n              trimmedCanvas.height = bounds.height;\n              const trimmedCtx = trimmedCanvas.getContext('2d');\n              \n              // Kopiujemy wycinek\n              trimmedCtx.drawImage(\n                  canvas, \n                  bounds.x, bounds.y, bounds.width, bounds.height, \n                  0, 0, bounds.width, bounds.height\n              );\n              \n              // Podmieniamy canvas na przycięty\n              canvas = trimmedCanvas;\n              ctx = trimmedCtx;\n          }\n      }\n      \n      // --- NOWA LOGIKA: Ograniczenie wymiarów (3000x3600) + optAddMargin ---\n      // Limit: 3000px szerokości, 3600px wysokości.\n      const MAX_W = 3000;\n      const MAX_H = 3600;\n      \n      // Decyzja o marginesie:\n      // 1. \"Warunkowy\" (ze starej opcji Kadrowanie) - tylko jeśli optCrop i nie optTrimOnly i shouldAddMargin\n      const conditionalMargin = (optCrop && !optTrimOnly && shouldAddMargin);\n      // 2. \"Wymuszony\" (nowa opcja) - zawsze jeśli optAddMargin\n      const forcedMargin = optAddMargin;\n      \n      // Czy w ogóle dodajemy margines?\n      const willAddMargin = conditionalMargin || forcedMargin;\n      \n      // Ile dodamy? (10px jeśli tak, 0 jeśli nie)\n      const marginAdd = willAddMargin ? 10 : 0;\n      \n      // Sprawdź obecne wymiary\n      let currentW = canvas.width;\n      let currentH = canvas.height;\n      \n      // Jeśli (current + margin) przekracza limit, musimy skalować TREŚĆ\n      if ( (currentW + marginAdd) > MAX_W || (currentH + marginAdd) > MAX_H ) {\n          // Obliczamy maksymalne wymiary dla SAMEJ TREŚCI (bez marginesu)\n          const maxContentW = MAX_W - marginAdd;\n          const maxContentH = MAX_H - marginAdd;\n          \n          // Skalowanie zachowujące proporcje (fit inside)\n          const scale = Math.min(maxContentW / currentW, maxContentH / currentH);\n          \n          const newW = Math.floor(currentW * scale);\n          const newH = Math.floor(currentH * scale);\n          \n          const scaledCanvas = document.createElement('canvas');\n          scaledCanvas.width = newW;\n          scaledCanvas.height = newH;\n          const scaledCtx = scaledCanvas.getContext('2d');\n          \n          // Wysoka jakość skalowania\n          scaledCtx.drawImage(canvas, 0, 0, newW, newH);\n          \n          canvas = scaledCanvas;\n          ctx = scaledCtx;\n      }\n\n      // Dodawanie marginesu (jeśli trzeba)\n      if (willAddMargin) {\n          const marginCanvas = document.createElement('canvas');\n          marginCanvas.width = canvas.width + 10; // 5px z lewej + 5px z prawej\n          marginCanvas.height = canvas.height + 10;\n          const marginCtx = marginCanvas.getContext('2d');\n          \n          // Tło białe\n          marginCtx.fillStyle = '#ffffff';\n          marginCtx.fillRect(0, 0, marginCanvas.width, marginCanvas.height);\n          \n          // Rysujemy obraz centralnie\n          marginCtx.drawImage(canvas, 5, 5);\n          \n          canvas = marginCanvas;\n          ctx = marginCtx;\n      }\n      // Padding do 500px (optResize)\n      if (optResize) {\n          const targetW = Math.max(canvas.width, 500);\n          const targetH = Math.max(canvas.height, 500);\n          \n          if (canvas.width < targetW || canvas.height < targetH) {\n              const paddedCanvas = document.createElement('canvas');\n              paddedCanvas.width = targetW;\n              paddedCanvas.height = targetH;\n              const paddedCtx = paddedCanvas.getContext('2d');\n              \n              // Tło białe\n              paddedCtx.fillStyle = '#ffffff';\n              paddedCtx.fillRect(0, 0, targetW, targetH);\n              \n              // Centrowanie\n              const dx = Math.floor((targetW - canvas.width) / 2);\n              const dy = Math.floor((targetH - canvas.height) / 2);\n              \n              paddedCtx.drawImage(canvas, dx, dy);\n              \n              canvas = paddedCanvas;\n              ctx = paddedCtx;\n          }\n      }\n\n      // Finalne spłaszczenie na białe tło (bo JPEG nie ma przezroczystości)\n      const finalCanvas = document.createElement('canvas');\n      finalCanvas.width = canvas.width;\n      finalCanvas.height = canvas.height;\n      const finalCtx = finalCanvas.getContext('2d');\n      finalCtx.fillStyle = '#ffffff';\n      finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);\n      finalCtx.drawImage(canvas, 0, 0);\n\n      // Konwersja do Blob (JPEG)\n      const blob = await new Promise(resolve => finalCanvas.toBlob(resolve, 'image/jpeg', 0.99));\n      \n      // Dodanie do ZIP\n      const fileName = `${baseName}-${startNumber + i}.jpg`;\n      zip.file(fileName, blob);\n      \n      processedCount++;\n\n    } catch (err) {\n      console.error('Błąd przetwarzania klienta:', err);\n      if (onProgress) onProgress(`Błąd: ${file.name}`);\n    }\n  }\n\n  if (onProgress) onProgress('Pakowanie ZIP...');\n  const zipBlob = await zip.generateAsync({ type: 'blob' });\n  return zipBlob;\n};\n"],"names":["loadImage","file","resolve","reject","img","getTrimmedBounds","ctx","width","height","pixels","top","bottom","left","right","isBackground","r","g","b","a","isWhite","isTransparent","rowHasContent","x","i","colHasContent","y","processFilesClientSide","filesQueue","options","onProgress","zip","JSZip","baseName","startNumber","optCrop","optTrimOnly","optAddMargin","optResize","processedCount","canvas","shouldAddMargin","corners","corner","idx","bounds","trimmedCanvas","trimmedCtx","MAX_W","MAX_H","willAddMargin","marginAdd","currentW","currentH","maxContentW","maxContentH","scale","newW","newH","scaledCanvas","scaledCtx","marginCanvas","marginCtx","targetW","targetH","paddedCanvas","paddedCtx","dx","dy","finalCanvas","finalCtx","blob","fileName","err"],"mappings":"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"}