{"version":3,"file":"client-processor-SJcInaeg.js","sources":["../../src/js/client-processor.js"],"sourcesContent":["import JSZip from 'jszip';\n\nconsole.log(\"Client processor module loaded\");\n\n// Funkcja pomocnicza do ładowania obrazu\nconst loadImage = (file) => {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = URL.createObjectURL(file);\n  });\n};\n\n// Algorytm TRIM (Scanlines)\nconst getTrimmedBounds = (ctx, width, height) => {\n  const pixels = ctx.getImageData(0, 0, width, height).data;\n  let top = 0, bottom = height, left = 0, right = width;\n\n  // Funkcja sprawdzająca czy piksel jest \"tłem\" (biały lub przezroczysty)\n  // Tolerancja dla bieli: RGB > 230\n  const isBackground = (r, g, b, a) => {\n    const isWhite = r > 230 && g > 230 && b > 230;\n    const isTransparent = a < 255;\n    return isWhite || isTransparent;\n  };\n\n  // Skanowanie z góry\n  for (top = 0; top < height; top++) {\n    let rowHasContent = false;\n    for (let x = 0; x < width; x++) {\n      const i = (top * width + x) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        rowHasContent = true;\n        break;\n      }\n    }\n    if (rowHasContent) break;\n  }\n\n  // Jeśli obraz jest pusty (samo tło)\n  if (top === height) return null;\n\n  // Skanowanie z dołu\n  for (bottom = height - 1; bottom >= top; bottom--) {\n    let rowHasContent = false;\n    for (let x = 0; x < width; x++) {\n      const i = (bottom * width + x) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        rowHasContent = true;\n        break;\n      }\n    }\n    if (rowHasContent) break;\n  }\n  // Skanowanie z lewej\n  for (left = 0; left < width; left++) {\n    let colHasContent = false;\n    for (let y = top; y <= bottom; y++) {\n      const i = (y * width + left) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        colHasContent = true;\n        break;\n      }\n    }\n    if (colHasContent) break;\n  }\n\n  // Skanowanie z prawej\n  for (right = width - 1; right >= left; right--) {\n    let colHasContent = false;\n    for (let y = top; y <= bottom; y++) {\n      const i = (y * width + right) * 4;\n      if (!isBackground(pixels[i], pixels[i+1], pixels[i+2], pixels[i+3])) {\n        colHasContent = true;\n        break;\n      }\n    }\n    if (colHasContent) break;\n  }\n  \n  return { x: left, y: top, width: right - left + 1, height: bottom - top + 1 };\n};\n\nexport const processFilesClientSide = async (filesQueue, options, onProgress) => {\n  const zip = new JSZip();\n  const { baseName, startNumber, optCrop, optResize } = options;\n\n  let processedCount = 0;\n\n  for (let i = 0; i < filesQueue.length; i++) {\n    const fileItem = filesQueue[i];\n    const file = fileItem.file;\n    \n    // Raportowanie postępu\n    if (onProgress) onProgress(`Przetwarzanie: ${file.name} (${i + 1}/${filesQueue.length})`);\n\n    try {\n      const img = await loadImage(file);\n      let canvas = document.createElement('canvas');\n      canvas.width = img.width;\n      canvas.height = img.height;\n      let ctx = canvas.getContext('2d', { willReadFrequently: true });\n      \n      // Rysujemy oryginał\n      ctx.drawImage(img, 0, 0);\n\n      // Logika flagi \"Should Add Margin\" (z serwera: białe rogi lub przezroczystość)\n      // Sprawdzamy 4 rogi oryginału\n      let shouldAddMargin = false;\n      if (optCrop) {\n          const corners = [\n            { x: 0, y: 0 },\n            { x: img.width - 1, y: 0 },\n            { x: 0, y: img.height - 1 },\n            { x: img.width - 1, y: img.height - 1 }\n          ];\n          const pixels = ctx.getImageData(0, 0, img.width, img.height).data;\n          \n          for(let corner of corners) {\n             const idx = (corner.y * img.width + corner.x) * 4;\n             const r = pixels[idx];\n             const g = pixels[idx+1];\n             const b = pixels[idx+2];\n             const a = pixels[idx+3];\n             \n             // Biały lub Przezroczysty\n             if ((r > 230 && g > 230 && b > 230) || a < 255) {\n                 shouldAddMargin = true;\n                 break;\n             }\n          }\n\n          // Logika TRIM\n          const bounds = getTrimmedBounds(ctx, canvas.width, canvas.height);\n          \n          if (bounds) {\n              // Sprawdź czy wymiary się zmieniły (czy coś przycięto)\n              // Uwaga: bounds może być null jeśli obraz pusty.\n              // Sprawdzamy różnicę wymiarów\n              if (bounds.width < canvas.width || bounds.height < canvas.height) {\n                  shouldAddMargin = true;\n              }\n\n              // Tworzymy nowy canvas dla przyciętego obrazu\n              const trimmedCanvas = document.createElement('canvas');\n              trimmedCanvas.width = bounds.width;\n              trimmedCanvas.height = bounds.height;\n              const trimmedCtx = trimmedCanvas.getContext('2d');\n              \n              // Kopiujemy wycinek\n              trimmedCtx.drawImage(\n                  canvas, \n                  bounds.x, bounds.y, bounds.width, bounds.height, \n                  0, 0, bounds.width, bounds.height\n              );\n              \n              // Podmieniamy canvas na przycięty\n              canvas = trimmedCanvas;\n              ctx = trimmedCtx;\n          }\n      }\n      \n      // Dodawanie marginesu (jeśli flaga aktywna)\n      if (optCrop && shouldAddMargin) {\n          const marginCanvas = document.createElement('canvas');\n          marginCanvas.width = canvas.width + 10; // 5px z lewej + 5px z prawej\n          marginCanvas.height = canvas.height + 10;\n          const marginCtx = marginCanvas.getContext('2d');\n          \n          // Tło białe\n          marginCtx.fillStyle = '#ffffff';\n          marginCtx.fillRect(0, 0, marginCanvas.width, marginCanvas.height);\n          \n          // Rysujemy obraz centralnie\n          marginCtx.drawImage(canvas, 5, 5);\n          \n          canvas = marginCanvas;\n          ctx = marginCtx;\n      }\n\n      // Padding do 500px (optResize)\n      if (optResize) {\n          const targetW = Math.max(canvas.width, 500);\n          const targetH = Math.max(canvas.height, 500);\n          \n          if (canvas.width < targetW || canvas.height < targetH) {\n              const paddedCanvas = document.createElement('canvas');\n              paddedCanvas.width = targetW;\n              paddedCanvas.height = targetH;\n              const paddedCtx = paddedCanvas.getContext('2d');\n              \n              // Tło białe\n              paddedCtx.fillStyle = '#ffffff';\n              paddedCtx.fillRect(0, 0, targetW, targetH);\n              \n              // Centrowanie\n              const dx = Math.floor((targetW - canvas.width) / 2);\n              const dy = Math.floor((targetH - canvas.height) / 2);\n              \n              paddedCtx.drawImage(canvas, dx, dy);\n              \n              canvas = paddedCanvas;\n              ctx = paddedCtx;\n          }\n      }\n\n      // Finalne spłaszczenie na białe tło (bo JPEG nie ma przezroczystości)\n      const finalCanvas = document.createElement('canvas');\n      finalCanvas.width = canvas.width;\n      finalCanvas.height = canvas.height;\n      const finalCtx = finalCanvas.getContext('2d');\n      finalCtx.fillStyle = '#ffffff';\n      finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);\n      finalCtx.drawImage(canvas, 0, 0);\n\n      // Konwersja do Blob (JPEG)\n      const blob = await new Promise(resolve => finalCanvas.toBlob(resolve, 'image/jpeg', 0.99));\n      \n      // Dodanie do ZIP\n      const fileName = `${baseName}-${startNumber + i}.jpg`;\n      zip.file(fileName, blob);\n      \n      processedCount++;\n\n    } catch (err) {\n      console.error('Błąd przetwarzania klienta:', err);\n      if (onProgress) onProgress(`Błąd: ${file.name}`);\n    }\n  }\n\n  if (onProgress) onProgress('Pakowanie ZIP...');\n  const zipBlob = await zip.generateAsync({ type: 'blob' });\n  return zipBlob;\n};\n"],"names":["loadImage","file","resolve","reject","img","getTrimmedBounds","ctx","width","height","pixels","top","bottom","left","right","isBackground","r","g","b","a","isWhite","isTransparent","rowHasContent","x","i","colHasContent","y","processFilesClientSide","filesQueue","options","onProgress","zip","JSZip","baseName","startNumber","optCrop","optResize","processedCount","canvas","shouldAddMargin","corners","corner","idx","bounds","trimmedCanvas","trimmedCtx","marginCanvas","marginCtx","targetW","targetH","paddedCanvas","paddedCtx","dx","dy","finalCanvas","finalCtx","blob","fileName","err"],"mappings":"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"}